---
title: "WasmCon NA 2025 Liveblog"
authors: [ericgregory] 
date: '2025-11-10'
description: 'Meet the wasmCloud team at KubeCon + CloudNativeCon NA 2025 in Atlanta!'
slug: wasmcon-na-25-liveblog
image: './images/wasmcon-header.webp'
---

Welcome to our liveblog of WasmCon at KubeCon + CloudNativeCon NA 2025 in Atlanta!

**Welcome + Opening Remarks**
Bailey Hayes, Cosmonic

Cosmonic CTO, W3C WebAssembly WASI Subgroup co-chair, and Bytecode Alliance At-Large Director Bailey Hayes opened WasmCon with a talk on WebAssembly's evolution from browser technology to universal runtime, including the major milestones from this year such as WebAssembly's 10th birthday and the growing ecosystem of language support.

Then she looked ahead to WASI P3 with some of the possibilities that it will unlock:

* Language-integrated concurrency
* Composable concurrency
* High-performance streaming

To help look ahead to WASI P3, Bailey introduced the first talk by Luke Wagner.

**Does the Component Model require extra copying?**  
Luke Wagner, Fastly

First, Luke reviewed the reasons you might use Wasm:

* Size - run on smaller devices, or get cost savings on larger devices.
* Cold start - more aggressively scale to zero
* Portability - Shift workloads dynamically to lower power, lower cost CPIs
* Sandboxing - Easily sandbox guest code with explicitly allowed APIs

Components take these features further with... 

* Free SDKs in the WIT IDL
* Virtual platform layering
* JS glue code for free
* Secure polyglot packages
* Modularity

But at what cost? Does it take extra copying to achieve these benefits?

In an HTTP request interface, we might define an http-handler interface that we import and export, and a response might be copied to resources for both of those. That's redundant. But it could be addressed with **resource types**, enabling us to create resources that might be shared as needed.

WASI 0.3 adds async functions and stream and future types for use in function signatures. Luke focused on streams as a solution to the copying problem, since streams can be passed around as needed.

Looking farther ahead, Luke discussed a minimalist memory mapping approach that may be promising post-1.0. This would allow zero-copy passing while preserving the shared-nothing property of the component model. 

In conclusion, Luke reviewed how much of the copying that occurs in the Component Model needs to happen anyway, and the problematic copying that remains has promising solutions at varying stages of development. So to answer the question in the title:

"Does the Component Model require extra copying?"

No.
...mostly
...but it's worth it
...and it'll get better over time.

*Keep checking back for updates on the latest talks!*
