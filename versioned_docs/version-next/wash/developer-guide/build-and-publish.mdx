---
title: 'Building and Publishing Components'
date: 2025-09-15T11:00:00+00:00
sidebar_position: 1
draft: false
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

**Wasm Shell** (`wash`) is the comprehensive command-line tool for developing, building, and publishing WebAssembly components.

In this section of the Developer Guide, you'll learn how to:

* Compile your project to a WebAssembly component binary
* Publish your component to an OCI registry

:::info[Prerequisites]
If you haven't completed the previous section on installing `wash`, creating a project, and starting a developer loop, we recommend [starting there](./index.mdx).
:::

## Building WebAssembly components

<Tabs groupId="lang" queryString>
  <TabItem value="rust" label="Rust" default>
  Use the `wash build` command from the root of a project directory to compile the component into a `.wasm` binary:

  ```shell
  wash build
  ```

  By default, the compiled `.wasm` binary for a Rust project is generated at `/target/wasm32-wasip2/debug/`. The output path for the compiled `.wasm` binary [can be configured via `wash`'s configuration file](../config.mdx).
  </TabItem>
  <TabItem value="tinygo" label="TinyGo">
  Use the `wash build` command from the root of a project directory to compile the component into a `.wasm` binary:

  ```shell
  wash build --skip-fetch
  ```

  By default, the compiled `.wasm` binary for a TinyGo project is generated at `/build/`. The output path for the compiled `.wasm` binary [can be configured via `wash`'s configuration file](../config.mdx).
  </TabItem>
  <TabItem value="typescript" label="TypeScript">
  Use the `wash build` command from the root of a project directory to compile the component into a `.wasm` binary:

  ```shell
  wash build
  ```

  By default, the compiled `.wasm` binary for a TypeScript project is generated at `/dist/`. The output path for the compiled `.wasm` binary [can be configured via `wash`'s configuration file](../config.mdx).
  </TabItem>
</Tabs>

:::warning[Directory context in `wash`]
You can run `wash build` from anywhere inside your project directory. From outside, you can use the `-C` flag to target a project directory. See the [Command Reference](../commands.mdx) for more information, as well as more options for the `wash build` command.
:::

### Build commands

Wasm Shell executes the build command for your language toolchain specified in the project's [`wash`'s configuration file](../config.mdx).

For example:

<Tabs groupId="lang" queryString>
  <TabItem value="rust" label="Rust" default>
```yaml
build:
  command: cargo build --target wasm32-wasip2 --release
  component_path: target/wasm32-wasip2/release/output.wasm
```
  </TabItem>
  <TabItem value="tinygo" label="TinyGo">
```yaml
build:
  command: go generate ./... && tinygo build -target wasip2 -wit-package ./wit -wit-world example -o build/output.wasm ./
  component_path: build/output.wasm
```
  </TabItem>
  <TabItem value="typescript" label="TypeScript">
```yaml
build:
  command: npm run install-and-build
  component_path: dist/output.wasm
```
  </TabItem>
</Tabs>

This configuration is used to build the component when you run `wash dev`, so it must be in place and properly configured for `wash dev` to work.

### Interface dependencies and `wash build`

When you run `wash build`, `wash` reads the specified world in your WIT files and downloads the appropriate dependencies automatically into the `wit/deps` directory. As such, in most cases you should add `wit/deps` to your `.gitignore` file.

Without any additional configuration, `wash` can download dependencies from the following namespaces (i.e. the `wasi` in `wasi:http@0.2.1`):

- `wasi`: Interfaces proposed for the common [WebAssembly System Interface (WASI) standard](https://wasi.dev/)
- `wasmcloud`: Interfaces maintained as part of the wasmCloud project (see the [Capability Catalog](/docs/capabilities/) to find first-party interfaces)
- `wrpc`: [Interfaces](/docs/reference/wasi/wrpc-interfaces) maintained as part of the WIT-over-RPC (wRPC) project
- `ba`: Interfaces maintained by the [Bytecode Alliance](https://bytecodealliance.org/)

## Components and OCI registries

Once you're finished iterating on your component, you can publish it to any OCI compliant registry that supports **OCI artifacts**. These artifacts are not container images, but conform to OCI standards and may be stored on any OCI-compatible registry. 

### Authenticating to OCI registries

`wash` supports the usage of Docker credentials for authentication to registries. There are multiple [ways to authenticate with Docker credentials](https://docs.docker.com/reference/cli/docker/login/), including the `docker login` command with the `docker` CLI:

```shell
docker login <registry> -u <username> -p <password-or-token> 
```

### Publishing to OCI registries

Push the component to your registry:

```shell
wash oci push ghcr.io/<namespace>/hello:0.2.0 ./dist/http-hello-world.wasm
```

* The target registry address (including artifact name and tag) are specified for the first option with `wash oci push`.
* The second option defines the target path for the component binary to push.